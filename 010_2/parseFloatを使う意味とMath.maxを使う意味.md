ざっくり言うと――

## `parseFloat` を使う意味

`getComputedStyle(cell).paddingTop` は `"10px"` のような **文字列** を返します。
このままでは数値計算できないので、**数値（px）に変換**します。

* 例

  ```js
  parseFloat('12.5px') // => 12.5   ← 小数も保持
  Number('12.5px')     // => NaN    ← 失敗
  parseInt('12.5px')   // => 12     ← 小数が失われる
  ```
* `parseFloat` を使うのは、**小数点を含む“サブピクセル”**（拡大縮小やDPIの影響で発生）も正確に扱えるからです。`parseInt` だと小数が落ちて誤差が出ます。

> 補足：padding には `auto` は来ないので `NaN` になる心配は基本ありません（`|| 0` を付けておくと更に安心）。

## `Math.max(0, h)` を使う意味

`h = clientHeight - paddingTop - paddingBottom` の差分計算は、サブピクセルの丸め誤差で **ごく小さな負値** になることがあります（例：`-0.2`）。
CSS の `height` に負の値は無効/不正なので、**0 未満にならないようクランプ（下限を0に固定）** しています。

* 例

  ```js
  Math.max(0, -0.2) // => 0
  ```
* `Math.abs`（絶対値）ではなく `Math.max(0, …)` を使うのは、**負になったら 0 にする**ことが目的だからです（正の値をそのまま保ち、負だけ切り捨て）。

---

つまりこの2つはそれぞれ

* `parseFloat`: 「"10px" → 10.0」にして**計算可能＆小数も保持**
* `Math.max(0, h)`: 丸め誤差での**負の高さを防ぐ安全弁**

という役割です。
